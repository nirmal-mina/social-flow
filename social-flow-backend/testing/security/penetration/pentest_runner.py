# =========================
# File: testing/security/penetration/pentest_runner.py
# =========================
"""
Command-line entrypoint for penetration tests.
Usage (example):
    python -m testing.security.penetration.pentest_runner --policy pentest_policies.yaml --target-file targets.yml --consent
"""

import argparse
import yaml
from pathlib import Path
from .engine import PentestEngine
from .utils.logger import get_logger

logger = get_logger("PentestRunner")

def load_targets(path):
    if not Path(path).exists():
        raise FileNotFoundError(f"Targets file not found: {path}")
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

def main():
    parser = argparse.ArgumentParser(description="Penetration testing runner (policy-driven, safe defaults).")
    parser.add_argument("--policy", default="pentest_policies.yaml", help="Policy YAML file")
    parser.add_argument("--targets", default="pentest_targets.yaml", help="YAML file with targets")
    parser.add_argument("--consent", action="store_true", help="Explicit consent to run non-simulated tests")
    parser.add_argument("--dry-run", action="store_true", help="Run in dry-run (simulation) mode")
    parser.add_argument("--report", default="pentest_report.json", help="Report output path")
    args = parser.parse_args()

    targets = load_targets(args.targets)
    engine = PentestEngine(policy_file=args.policy, consent=args.consent, dry_run=args.dry_run)

    final_reports = {}
    for t in targets.get("targets", []):
        name = t.get("name")
        meta = t.get("meta", {})
        logger.info(f"Running tests for target {name}")
        res = engine.run_for_target(name, meta)
        report_path = engine.generate_report(res, name, outpath=f"{name}_{args.report}", fmt="json")
        final_reports[name] = {"result": res, "report": report_path}

    logger.info("All targets processed.")
    print(final_reports)

if __name__ == "__main__":
    main()
