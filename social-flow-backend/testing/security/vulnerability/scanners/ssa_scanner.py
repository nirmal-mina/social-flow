# =========================
# File: testing/security/vulnerability/scanners/ssa_scanner.py
"""
Static source analysis (SSA) - lightweight AST-based heuristics for Python and JS.
- Python: parse AST and detect string concatenation into SQL exec, use of eval, subprocess with unsanitized input
- JS: basic regex heuristics (non-exhaustive)
This is intentionally conservative and designed to surface candidates, not certain vulnerabilities.
"""
from pathlib import Path
import ast
import re
from ..utils.logger import get_logger

logger = get_logger("SSAScanner")

def scan(repo_path: Path, file_types=None):
    if file_types is None:
        file_types = [".py"]
    repo = Path(repo_path)
    issues = {}
    for ft in file_types:
        for p in repo.rglob(f"*{ft}"):
            try:
                if ft == ".py":
                    file_issues = _scan_python(p)
                else:
                    file_issues = _scan_text(p, ft)
                if file_issues:
                    issues[str(p)] = file_issues
            except Exception as e:
                logger.debug(f"SSA scan error {p}: {e}")
    return {"issues": issues}

def _scan_python(path: Path):
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        src = f.read()
    tree = ast.parse(src)
    findings = []
    # detect use of eval/exec/call to subprocess with suspicious args
    for node in ast.walk(tree):
        # eval/exec
        if isinstance(node, ast.Call) and getattr(node.func, "id", "") in ("eval", "exec"):
            findings.append({"type": "eval_exec_usage", "lineno": getattr(node, "lineno", None), "detail": ast.get_source_segment(src, node)[:200]})
        # subprocess.run/call with non-constant args
        if isinstance(node, ast.Call):
            func = node.func
            if isinstance(func, ast.Attribute) and getattr(func.value, "id", "") == "subprocess":
                # if any arg is not a Constant or not a list literal -> suspicious
                for arg in node.args:
                    if not isinstance(arg, (ast.Constant, ast.List, ast.Tuple)):
                        findings.append({"type": "subprocess_dynamic_args", "lineno": getattr(node, "lineno", None)})
        # string concat used in SQL-like functions
        if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
            # check parent call if it's used as SQL argument
            parent = getattr(node, "parent", None)
            # conservative: flag the concat expression itself
            findings.append({"type": "string_concat", "lineno": getattr(node, "lineno", None)})
    return findings

def _scan_text(path: Path, ft):
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        txt = f.read()
    findings = []
    if ft == ".js":
        # naive detections
        if re.search(r"\beval\(", txt):
            findings.append({"type": "eval_usage", "snippet": _snippet(txt, "eval(")})
        if re.search(r"document\.cookie", txt):
            findings.append({"type": "document_cookie_usage"})
    return findings

def _snippet(text, pattern, ctx=40):
    idx = text.find(pattern)
    if idx == -1:
        return ""
    start = max(0, idx-ctx)
    end = min(len(text), idx+ctx)
    return text[start:end]
