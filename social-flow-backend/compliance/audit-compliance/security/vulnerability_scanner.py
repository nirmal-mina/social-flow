# vulnerability_scanner.py
import datetime
import math
from typing import List, Dict, Any
from .utils import log_event, secure_hash

# A small CVE-like data model (in real life you'd query NVD or vendor feeds)
# Each vulnerability: { "id": "CVE-2025-XXXX", "package": "openssl", "version_range": "<=1.1.1", "cvss": 9.8, "description": "..." }

class VulnerabilityScanner:
    """
    Lightweight scanner that:
    - Accepts an inventory (packages with versions, container images, OS packages).
    - Matches known vulnerabilities (local feed or supplied list).
    - Produces prioritized findings with contextual risk score.
    """

    def __init__(self, vuln_feed: List[Dict[str, Any]] = None):
        self.vuln_feed = vuln_feed or []
        # Build an index for quick matching: package -> list of vulns
        self.index = {}
        self._build_index()

    def _build_index(self):
        for v in self.vuln_feed:
            pkg = v.get("package")
            self.index.setdefault(pkg, []).append(v)

    @staticmethod
    def _version_in_range(version: str, version_range: str) -> bool:
        """
        Rudimentary semantic version comparison supporting:
        - <=x.y.z, <x.y.z, >=x.y.z, >x.y.z, ==x.y.z
        - For complex ranges production code should use packaging.version or semver
        """
        try:
            from packaging.version import Version
        except Exception:
            # Fallback naive parse if packaging not available
            def parse(v): return tuple(int(p) for p in v.split(".") if p.isdigit())
            cmp_version = parse(version)
            target = parse(version_range.lstrip("<=><=:"))
            op = version_range[:2] if version_range[:2] in ("<=", ">=") else version_range[0]
            if op == "<":
                return cmp_version < target
            if op == "<=":
                return cmp_version <= target
            if op == ">":
                return cmp_version > target
            if op == ">=":
                return cmp_version >= target
            if op == "=" or op == "==":
                return cmp_version == target
            return False
        # If packaging available:
        op = version_range[:2] if version_range[:2] in ("<=", ">=") else version_range[0]
        target_v = Version(version_range.lstrip("<=><=:"))
        v_obj = Version(version)
        if op == "<":
            return v_obj < target_v
        if op == "<=":
            return v_obj <= target_v
        if op == ">":
            return v_obj > target_v
        if op == ">=":
            return v_obj >= target_v
        if op in ("=", "=="):
            return v_obj == target_v
        return False

    @staticmethod
    def _compute_contextual_score(cvss: float, age_days: int, exposure: float) -> float:
        """
        Compute a simple contextual risk score combining CVSS, age, and exposure.
        - cvss: base severity (0-10)
        - age_days: days since disclosure (older may be more exploitable if unpatched)
        - exposure: fraction of assets exposed to internet (0.0-1.0)
        Returns normalized 0-100 score.
        """
        age_factor = min(1.0, math.log1p(age_days) / 10.0)  # growth with age but saturates
        score = cvss / 10.0 * 0.6 + age_factor * 0.2 + exposure * 0.2
        return round(score * 100, 2)

    def scan_inventory(self, inventory: List[Dict[str, Any]], today: datetime.date = None) -> List[Dict[str, Any]]:
        """
        inventory items: {"package": "openssl", "version": "1.1.0", "asset_id": "server-1", "exposed": True}
        """
        findings = []
        today = today or datetime.date.today()
        for item in inventory:
            pkg = item.get("package")
            ver = item.get("version")
            asset_id = item.get("asset_id")
            exposed = 1.0 if item.get("exposed", False) else 0.0
            for vuln in self.index.get(pkg, []):
                if self._version_in_range(ver, vuln.get("version_range", "")):
                    # compute age
                    disclosed = vuln.get("disclosed_on")
                    age_days = (today - disclosed).days if isinstance(disclosed, datetime.date) else 0
                    score = self._compute_contextual_score(vuln.get("cvss", 5.0), age_days, exposed)
                    finding = {
                        "vuln_id": vuln.get("id"),
                        "package": pkg,
                        "version": ver,
                        "asset_id": asset_id,
                        "cvss": vuln.get("cvss"),
                        "description": vuln.get("description"),
                        "age_days": age_days,
                        "exposure": exposed,
                        "contextual_score": score
                    }
                    findings.append(finding)
                    log_event(f"Vulnerability found: {vuln.get('id')} on {asset_id}", level="WARNING", vuln_id=vuln.get("id"), asset=asset_id)
        # Sort findings by contextual_score descending
        findings.sort(key=lambda f: f["contextual_score"], reverse=True)
        return findings

    def add_feed(self, vuln_list: List[Dict[str, Any]]):
        """Add more vulnerabilities to the feed and rebuild index."""
        self.vuln_feed.extend(vuln_list)
        self._build_index()
        log_event(f"Added {len(vuln_list)} vulnerabilities to feed", level="INFO")

